# name: Local Test - CI/CD Next.js

# on:
#   push:
#     branches: ["main"]
#   workflow_dispatch:

# jobs:
#   build-and-test-deploy:
#     runs-on: ubuntu-latest

#     steps:
#       - name: üõí Checkout repository
#         uses: actions/checkout@v4

#       - name: ‚öôÔ∏è Set up Node.js
#         uses: actions/setup-node@v4
#         with:
#           node-version: 20

#       - name: üì¶ Install dependencies
#         run: npm ci

#       - name: üèóÔ∏è Build Next.js app
#         run: npm run build

#       - name: üîç Verify build output
#         run: |
#           echo "üìç Current directory: $(pwd)"
#           if [ -d ".next" ]; then
#             echo "‚úÖ .next directory exists:"
#             ls -la .next
#           else
#             echo "‚ùå .next directory not found!"
#             exit 1
#           fi

#       - name: üóúÔ∏è Compress .next folder
#         run: |
#           tar -czf next-build.tar.gz .next
#           echo "‚úÖ Created archive:"
#           ls -lh next-build.tar.gz

#       - name: üöÄ Upload build artifact (for testing)
#         uses: actions/upload-artifact@v4
#         with:
#           name: next-build
#           path: next-build.tar.gz

#       - name: üì¶ Simulate "Deploy" locally
#         run: |
#           mkdir -p deploy_output
#           cp next-build.tar.gz deploy_output/
#           cd deploy_output
#           tar -xzf next-build.tar.gz
#           echo "‚úÖ Simulated deployment complete:"
#           ls -la .next

#       - name: ‚úÖ Verify simulated deployment
#         run: |
#           echo "App deployed to local 'deploy_output' folder!"
#           ls -la deploy_output/.next



# name: CI/CD - Next.js Build & Windows Deploy (12:01 AM IST)

# on:
#   push:
#     branches: ["main"]
#   workflow_dispatch:
#   schedule:
#     - cron: "31 18 * * *" # 12:01 AM IST (18:31 UTC)

# jobs:
#   build-and-deploy:
#     runs-on: windows-latest

#     steps:
#       # ------------------ CI: BUILD ------------------
#       - name: üõí Checkout repository
#         uses: actions/checkout@v4

#       - name: ‚öôÔ∏è Set up Node.js
#         uses: actions/setup-node@v4
#         with:
#           node-version: 20

#       - name: üì¶ Install dependencies
#         run: npm ci
#         shell: powershell

#       - name: üèóÔ∏è Build Next.js app
#         run: npm run build
#         shell: powershell

#       - name: üóúÔ∏è Create build archive
#         run: |
#           if (Test-Path "next-build.tar.gz") { Remove-Item next-build.tar.gz -Force }
#           tar -czf next-build.tar.gz .next
#           Write-Host "‚úÖ Build archived successfully."
#         shell: powershell

#       # ------------------ CD: DEPLOY ------------------
#       - name: üöÄ Deploy to Windows Server via WinRM
#         shell: pwsh
#         env:
#           SERVER_HOST: ${{ secrets.SERVER_HOST }}
#           SERVER_USER: ${{ secrets.SERVER_USER }}
#           SERVER_PASS: ${{ secrets.SERVER_PASS }}
#         run: |
#           Write-Host "üîß Configuring WinRM client on GitHub runner..."
#           winrm set winrm/config/client '@{AllowUnencrypted="true"}'
#           winrm set winrm/config/client/auth '@{Basic="true"}'
#           winrm set winrm/config/client '@{TrustedHosts="*"}'
#           Write-Host "‚úÖ WinRM client configured and TrustedHosts set."

#           Write-Host "üîó Connecting to $env:SERVER_HOST ..."
#           $secpass = ConvertTo-SecureString $env:SERVER_PASS -AsPlainText -Force
#           $creds = New-Object System.Management.Automation.PSCredential ($env:SERVER_USER, $secpass)
#           $session = New-PSSession -ComputerName $env:SERVER_HOST -Port 5985 -Credential $creds -Authentication Basic -UseSSL:$false

#           Write-Host "üì¶ Uploading build to remote server..."
#           Copy-Item -ToSession $session -Path "next-build.tar.gz" -Destination "C:\inetpub\wwwroot\next-app\next-build.tar.gz" -Force

#           Invoke-Command -Session $session -ScriptBlock {
#             Write-Host "üîß Preparing deploy folder..."
#             if (!(Test-Path "C:\inetpub\wwwroot\next-app")) {
#               New-Item -ItemType Directory -Path "C:\inetpub\wwwroot\next-app" | Out-Null
#             }

#             Set-Location "C:\inetpub\wwwroot\next-app"
#             Write-Host "üìÇ Extracting build..."
#             tar -xzf next-build.tar.gz
#             Remove-Item next-build.tar.gz -Force
#             Write-Host "‚úÖ Build extracted successfully."

#             Write-Host "üîÑ Restarting Next.js app with PM2..."
#             pm2 restart next-app -f -s 2>$null
#             if ($LASTEXITCODE -ne 0) {
#               Write-Host "App not found ‚Äî starting a new PM2 process."
#               pm2 start npm --name "next-app" -- run start
#             }

#             # Log deployment timestamp
#             $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
#             Add-Content "C:\inetpub\wwwroot\next-app\deploy-log.txt" "Deployed at $timestamp"
#             Write-Host "üöÄ Deployment completed and logged."
#           }

#           Remove-PSSession $session


# name: CI/CD - Next.js Build & Windows Deploy (HTTP)

# on:
#   push:
#     branches: ["main"]
#   workflow_dispatch:
#   schedule:
#     - cron: "31 18 * * *" # 12:01 AM IST (18:31 UTC)

# jobs:
#   build-and-deploy:
#     runs-on: windows-latest

#     steps:
#       - name: üõí Checkout repository
#         uses: actions/checkout@v4

#       - name: ‚öôÔ∏è Set up Node.js
#         uses: actions/setup-node@v4
#         with:
#           node-version: 20

#       - name: üì¶ Install dependencies
#         run: npm ci
#         shell: powershell

#       - name: üèóÔ∏è Build Next.js app
#         run: npm run build
#         shell: powershell

#       - name: üóúÔ∏è Create build archive
#         run: |
#           if (Test-Path "next-build.tar.gz") { Remove-Item next-build.tar.gz -Force }
#           tar -czf next-build.tar.gz .next package.json
#           Write-Host "‚úÖ Build archived successfully."
#         shell: powershell

#       # ------------------ DEPLOY ------------------
#       - name: üöÄ Deploy via WinRM HTTP (Port 5985)
#         shell: pwsh
#         env:
#           SERVER_HOST: ${{ secrets.SERVER_HOST }}
#           SERVER_USER: ${{ secrets.SERVER_USER }}
#           SERVER_PASS: ${{ secrets.SERVER_PASS }}
#         run: |
#           Write-Host "üîß Configuring WinRM client on GitHub runner..."
#           try {
#             winrm set winrm/config/client/auth '@{Basic="true"}'
#             winrm set winrm/config/client '@{TrustedHosts="*"}'
#             winrm set winrm/config/client '@{AllowUnencrypted="true"}'
#             Write-Host "‚úÖ WinRM client configured."
#           } catch {
#             Write-Host "‚ùå Failed configuring WinRM client:"
#             Write-Host $_.Exception.Message
#             exit 1
#           }

#           Write-Host "üîó Connecting to $env:SERVER_HOST on Port 5985..."
#           $secpass = ConvertTo-SecureString $env:SERVER_PASS -AsPlainText -Force
#           $creds = New-Object System.Management.Automation.PSCredential ($env:SERVER_USER, $secpass)

#           $session = $null
#           $maxAttempts = 5
#           for ($i = 1; $i -le $maxAttempts; $i++) {
#             try {
#               Write-Host "üß† Attempt ${i}: Trying to create PSSession..."
#               $session = New-PSSession -ComputerName $env:SERVER_HOST -Port 5985 `
#                 -Credential $creds -Authentication Basic -UseSSL:$false -ErrorAction Stop
#               Write-Host "‚úÖ Connected successfully on attempt ${i}"
#               break
#             } catch {
#               Write-Host "‚ö†Ô∏è Attempt ${i} failed. Retrying..."
#               Start-Sleep -Seconds 5
#               if ($i -eq $maxAttempts) { throw "‚ùå Failed to connect after ${maxAttempts} attempts." }
#             }
#           }

#           Write-Host "üì¶ Uploading build..."
#           Copy-Item -ToSession $session -Path "next-build.tar.gz" `
#             -Destination "C:\inetpub\wwwroot\next-app\next-build.tar.gz" -Force
#           Write-Host "‚úÖ Build uploaded successfully."

#           Write-Host "üß© Running remote deployment..."
#           Invoke-Command -Session $session -ScriptBlock {
#             $deployPath = "C:\inetpub\wwwroot\next-app"
#             Write-Host "üîß Preparing deploy folder..."
#             if (!(Test-Path $deployPath)) { New-Item -ItemType Directory -Path $deployPath | Out-Null }
#             Set-Location $deployPath

#             Write-Host "üìÇ Extracting build..."
#             if (Test-Path ".next") { Remove-Item .next -Recurse -Force }
#             if (Test-Path "package.json") { Remove-Item package.json -Force }
#             tar -xzf next-build.tar.gz
#             Remove-Item next-build.tar.gz -Force

#             Write-Host "‚öôÔ∏è Installing dependencies..."
#             npm install --omit=dev

#             Write-Host "üõ†Ô∏è Ensuring PM2 is available..."
#             $pm2Path = 'C:\Users\Administrator\AppData\Roaming\npm'
#             if (!(Test-Path "$pm2Path\pm2.ps1")) {
#               npm install pm2 -g
#               Write-Host "‚úÖ PM2 installed globally."
#             }

#             # Add PM2 to path for this session
#             [System.Environment]::SetEnvironmentVariable("Path", $env:Path + ";$pm2Path", [System.EnvironmentVariableTarget]::Process)
#             $env:Path += ";$pm2Path"
#             Write-Host "‚úÖ PM2 path added: $pm2Path"

#             Write-Host "üîÑ Restarting or starting app with PM2..."
#             try {
#               pm2 delete next-app -s 2>$null | Out-Null
#               $rawOutput = pm2 start npm --name "next-app" -- run start --no-warnings | Out-String
#               $cleanOutput = $rawOutput -replace '[^\x20-\x7E]', ''  # strip non-ASCII characters
#               Write-Host $cleanOutput
#               pm2 save | Out-Null
#               Write-Host "‚úÖ PM2 app started and saved successfully."
#             } catch {
#               Write-Host "‚ö†Ô∏è PM2 error:"
#               Write-Host $_.Exception.Message
#             }

#             pm2 list | Out-String | Out-File "$deployPath\pm2-status.txt" -Encoding utf8
#             Write-Host "üìÑ PM2 status saved to pm2-status.txt"

#             $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
#             Add-Content "$deployPath\deploy-log.txt" "Deployed successfully at $timestamp"
#             Write-Host "üöÄ Deployment completed and logged successfully."
#           } -ErrorAction SilentlyContinue

#           Write-Host "‚úÖ Deployment finished cleanly on remote server."
#           Remove-PSSession $session
#           exit 0



# name: CI/CD - Next.js Build & Windows Deploy (HTTP, Multi-Server)

# on:
#   push:
#     branches: ["main"]
#   workflow_dispatch:
#   schedule:
#     - cron: "31 18 * * *" # 12:01 AM IST (18:31 UTC)

# jobs:
#   build-and-deploy:
#     runs-on: windows-latest

#     # üëá Matrix defines multiple servers
#     strategy:
#       matrix:
#         include:
#           - name: server1
#             host: ${{ secrets.SERVER1_HOST }}
#             user: ${{ secrets.SERVER1_USER }}
#             pass: ${{ secrets.SERVER1_PASS }}
#           - name: server2
#             host: ${{ secrets.SERVER2_HOST }}
#             user: ${{ secrets.SERVER2_USER }}
#             pass: ${{ secrets.SERVER2_PASS }}

#     name: Deploy to ${{ matrix.name }}

#     steps:
#       # ------------------ CI: BUILD ------------------
#       - name: üõí Checkout repository
#         uses: actions/checkout@v4

#       - name: ‚öôÔ∏è Set up Node.js
#         uses: actions/setup-node@v4
#         with:
#           node-version: 20

#       - name: üì¶ Install dependencies
#         run: npm ci
#         shell: powershell

#       - name: üèóÔ∏è Build Next.js app
#         run: npm run build
#         shell: powershell

#       - name: üóúÔ∏è Create build archive
#         run: |
#           if (Test-Path "next-build.tar.gz") { Remove-Item next-build.tar.gz -Force }
#           tar -czf next-build.tar.gz .next package.json
#           Write-Host "‚úÖ Build archived successfully."
#         shell: powershell

#       # ------------------ CD: DEPLOY ------------------
#       - name: üöÄ Deploy to ${{ matrix.name }} via WinRM HTTP
#         shell: pwsh
#         env:
#           SERVER_HOST: ${{ matrix.host }}
#           SERVER_USER: ${{ matrix.user }}
#           SERVER_PASS: ${{ matrix.pass }}
#         run: |
#           Write-Host "üîß Configuring WinRM client..."
#           try {
#             winrm set winrm/config/client/auth '@{Basic="true"}'
#             winrm set winrm/config/client '@{TrustedHosts="*"}'
#             winrm set winrm/config/client '@{AllowUnencrypted="true"}'
#             Write-Host "‚úÖ WinRM client configured."
#           } catch {
#             Write-Host "‚ùå Failed configuring WinRM client:"; Write-Host $_.Exception.Message; exit 1
#           }

#           Write-Host "üîó Connecting to $env:SERVER_HOST ..."
#           $secpass = ConvertTo-SecureString $env:SERVER_PASS -AsPlainText -Force
#           $creds = New-Object System.Management.Automation.PSCredential ($env:SERVER_USER, $secpass)

#           $session = $null
#           $maxAttempts = 5
#           for ($i = 1; $i -le $maxAttempts; $i++) {
#             try {
#               Write-Host "üß† Attempt ${i}: Trying to create PSSession..."
#               $session = New-PSSession -ComputerName $env:SERVER_HOST -Port 5985 `
#                 -Credential $creds -Authentication Basic -UseSSL:$false -ErrorAction Stop
#               Write-Host "‚úÖ Connected successfully on attempt ${i}"
#               break
#             } catch {
#               Write-Host "‚ö†Ô∏è Attempt ${i} failed: $($_.Exception.Message)"
#               Start-Sleep -Seconds 5
#               if ($i -eq $maxAttempts) { throw "‚ùå Failed after ${maxAttempts} attempts." }
#             }
#           }

#           Write-Host "üì¶ Uploading build to $env:SERVER_HOST..."
#           Copy-Item -ToSession $session -Path "next-build.tar.gz" `
#             -Destination "C:\inetpub\wwwroot\next-app\next-build.tar.gz" -Force

#           Write-Host "üß© Running remote deployment on $env:SERVER_HOST..."
#           Invoke-Command -Session $session -ScriptBlock {
#             $deployPath = "C:\inetpub\wwwroot\next-app"
#             Write-Host "üîß Preparing deploy folder..."
#             if (!(Test-Path $deployPath)) { New-Item -ItemType Directory -Path $deployPath | Out-Null }
#             Set-Location $deployPath

#             Write-Host "üìÇ Extracting build..."
#             if (Test-Path ".next") { Remove-Item .next -Recurse -Force }
#             if (Test-Path "package.json") { Remove-Item package.json -Force }
#             tar -xzf next-build.tar.gz
#             Remove-Item next-build.tar.gz -Force

#             Write-Host "‚öôÔ∏è Installing dependencies..."
#             npm install --omit=dev

#             Write-Host "üõ†Ô∏è Ensuring PM2 is available..."
#             $pm2Path = 'C:\Users\Administrator\AppData\Roaming\npm'
#             if (!(Test-Path "$pm2Path\pm2.ps1")) {
#               npm install pm2 -g
#               Write-Host "‚úÖ PM2 installed globally."
#             }

#             # Add PM2 to path for this session
#             [System.Environment]::SetEnvironmentVariable("Path", $env:Path + ";$pm2Path", [System.EnvironmentVariableTarget]::Process)
#             $env:Path += ";$pm2Path"
#             Write-Host "‚úÖ PM2 path added: $pm2Path"

#             Write-Host "üîÑ Restarting or starting app with PM2..."
#             try {
#               pm2 delete next-app -s 2>$null | Out-Null
#               $rawOutput = pm2 start npm --name "next-app" -- run start --no-warnings | Out-String
#               $cleanOutput = $rawOutput -replace '[^\x20-\x7E]', ''
#               Write-Host $cleanOutput
#               pm2 save | Out-Null
#               Write-Host "‚úÖ PM2 app started and saved successfully."
#             } catch {
#               Write-Host "‚ö†Ô∏è PM2 error: $($_.Exception.Message)"
#             }

#             pm2 list | Out-String | Out-File "$deployPath\pm2-status.txt" -Encoding utf8
#             $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
#             Add-Content "$deployPath\deploy-log.txt" "Deployed successfully at $timestamp"
#             Write-Host "üöÄ Deployment completed and logged successfully."
#           } -ErrorAction SilentlyContinue

#           Write-Host "‚úÖ Deployment finished cleanly on $env:SERVER_HOST."
#           Remove-PSSession $session
#           exit 0

# name: CI/CD - Next.js Build & Windows Deploy (Multi-Server Stable)

# on:
#   push:
#     branches: ["main"]
#   workflow_dispatch:
#   schedule:
#     - cron: "31 18 * * *" # 12:01 AM IST (18:31 UTC)

# jobs:
#   build-and-deploy:
#     runs-on: windows-latest

#     # Matrix defines server labels, not secrets
#     strategy:
#       matrix:
#         include:
#           - name: server1
#             label: SERVER1
#           - name: server2
#             label: SERVER2

#     name: Deploy to ${{ matrix.name }}

#     steps:
#       # ------------------ CI: BUILD ------------------
#       - name: üõí Checkout repository
#         uses: actions/checkout@v4

#       - name: ‚öôÔ∏è Set up Node.js
#         uses: actions/setup-node@v4
#         with:
#           node-version: 20

#       - name: üì¶ Install dependencies
#         run: npm ci
#         shell: powershell

#       - name: üèóÔ∏è Build Next.js app
#         run: npm run build
#         shell: powershell

#       - name: üóúÔ∏è Create build archive (safe with optional files)
#         shell: pwsh
#         run: |
#              Write-Host "üóúÔ∏è Creating build archive safely..."
#              if (Test-Path "next-build.tar.gz") { Remove-Item next-build.tar.gz -Force }

#              # Check mandatory items
#                if (-not (Test-Path ".next")) { Write-Host "‚ùå .next folder missing!"; exit 1 }
#                if (-not (Test-Path "package.json")) { Write-Host "‚ùå package.json missing!"; exit 1 }

#              # Collect items
#                 $tarItems = @(".next", "package.json")
#                  if (Test-Path "public") { $tarItems += "public" }
#                   if (Test-Path "next.config.js") { $tarItems += "next.config.js" }
       
#                 Write-Host "üì¶ Archiving: $($tarItems -join ', ')"

#                 # Use Join-String to safely build argument list
#                     $tarArgs = $tarItems -join ' '
#                     cmd /c "tar -czf next-build.tar.gz $tarArgs"

#               if ($LASTEXITCODE -eq 0) {
#                 Write-Host "‚úÖ Build archive created successfully."
#               } else {
#                Write-Host "‚ö†Ô∏è tar returned non-zero exit code ($LASTEXITCODE)."
#               exit 1
#                 }
          

#       # ------------------ CD: DEPLOY ------------------
#       - name: üöÄ Deploy via WinRM HTTP (Port 5985)
#         shell: pwsh
#         env:
#           SERVER1_HOST: ${{ secrets.SERVER1_HOST }}
#           SERVER1_USER: ${{ secrets.SERVER1_USER }}
#           SERVER1_PASS: ${{ secrets.SERVER1_PASS }}
#           SERVER2_HOST: ${{ secrets.SERVER2_HOST }}
#           SERVER2_USER: ${{ secrets.SERVER2_USER }}
#           SERVER2_PASS: ${{ secrets.SERVER2_PASS }}
#         run: |
#           # Dynamically select server credentials
#           switch ("${{ matrix.label }}") {
#             "SERVER1" {
#               $env:SERVER_HOST = $env:SERVER1_HOST
#               $env:SERVER_USER = $env:SERVER1_USER
#               $env:SERVER_PASS = $env:SERVER1_PASS
#             }
#             "SERVER2" {
#               $env:SERVER_HOST = $env:SERVER2_HOST
#               $env:SERVER_USER = $env:SERVER2_USER
#               $env:SERVER_PASS = $env:SERVER2_PASS
#             }
#           }

#           Write-Host "üîß Configuring WinRM client..."
#           try {
#             winrm set winrm/config/client/auth '@{Basic="true"}'
#             winrm set winrm/config/client '@{TrustedHosts="*"}'
#             winrm set winrm/config/client '@{AllowUnencrypted="true"}'
#             Write-Host "‚úÖ WinRM client configured."
#           } catch {
#             Write-Host "‚ùå WinRM configuration failed: $($_.Exception.Message)"
#             exit 1
#           }

#           Write-Host "üîó Connecting to $env:SERVER_HOST on port 5985..."
#           $secpass = ConvertTo-SecureString $env:SERVER_PASS -AsPlainText -Force
#           $creds = New-Object System.Management.Automation.PSCredential ($env:SERVER_USER, $secpass)

#           $session = $null
#           for ($i = 1; $i -le 5; $i++) {
#             try {
#               Write-Host "üß† Attempt ${i}: Creating PSSession..."
#               $session = New-PSSession -ComputerName $env:SERVER_HOST -Port 5985 `
#                 -Credential $creds -Authentication Basic -UseSSL:$false -ErrorAction Stop
#               Write-Host "‚úÖ Connected successfully."
#               break
#             } catch {
#               Write-Host "‚ö†Ô∏è Connection failed ($i): $($_.Exception.Message)"
#               Start-Sleep -Seconds 5
#               if ($i -eq 5) { throw "‚ùå Failed after 5 attempts." }
#             }
#           }

#           # Ensure deploy directory exists
#           Invoke-Command -Session $session -ScriptBlock {
#             if (!(Test-Path "C:\inetpub\wwwroot\next-app")) {
#               Write-Host "üìÅ Creating deploy folder..."
#               New-Item -ItemType Directory -Path "C:\inetpub\wwwroot\next-app" | Out-Null
#             }
#           }

#           Write-Host "üì¶ Uploading build..."
#           Copy-Item -ToSession $session -Path "next-build.tar.gz" `
#             -Destination "C:\inetpub\wwwroot\next-app\next-build.tar.gz" -Force
#           Write-Host "‚úÖ Build uploaded successfully."

#           Write-Host "üß© Running remote deployment..."
#           Invoke-Command -Session $session -ScriptBlock {
#             $deployPath = "C:\inetpub\wwwroot\next-app"
#             Set-Location $deployPath

#             Write-Host "üìÇ Extracting new build..."
#             if (Test-Path ".next") { Remove-Item .next -Recurse -Force }
#             if (Test-Path "package.json") { Remove-Item package.json -Force }
#             if (Test-Path "public") { Remove-Item public -Recurse -Force }
#             tar -xzf next-build.tar.gz
#             Remove-Item next-build.tar.gz -Force

#             Write-Host "‚öôÔ∏è Installing dependencies (this may take a few minutes)..."

#              # üõ†Ô∏è Keep-alive job so GitHub doesn‚Äôt cancel the action
#             $keepAlive = Start-Job -ScriptBlock {
#             while ($true) {
#              Write-Host "üí§ npm install still running... $(Get-Date -Format 'HH:mm:ss')"
#              Start-Sleep -Seconds 60
#              }
#              }

#              try {
#              npm install --omit=dev
#              }
#             finally {
#                  Stop-Job $keepAlive -Force | Out-Null
#                  Remove-Job $keepAlive -Force | Out-Null
#                 }

#                Write-Host "‚úÖ Dependencies installed successfully."


#             Write-Host "üõ†Ô∏è Ensuring PM2 is available..."
#             $pm2Path = 'C:\Users\Administrator\AppData\Roaming\npm'
#             if (!(Test-Path "$pm2Path\pm2.ps1")) {
#               npm install pm2 -g
#               Write-Host "‚úÖ PM2 installed globally."
#             }
#             [System.Environment]::SetEnvironmentVariable("Path", $env:Path + ";$pm2Path", [System.EnvironmentVariableTarget]::Process)
#             $env:Path += ";$pm2Path"

#             Write-Host "üîÑ Restarting or starting app with PM2..."
#             try {
#               pm2 delete next-app -s 2>$null | Out-Null
#               pm2 start npm --name "next-app" -- run start --no-warnings | Out-Null
#               pm2 save | Out-Null
#               Write-Host "‚úÖ PM2 restarted successfully."
#             } catch {
#               Write-Host "‚ö†Ô∏è PM2 error:"; Write-Host $_.Exception.Message
#             }

#             $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
#             Add-Content "$deployPath\deploy-log.txt" "Deployed successfully at $timestamp"
#             Write-Host "üöÄ Deployment completed successfully."
#           }

#           Remove-PSSession $session
#           Write-Host "‚úÖ Deployment finished for $env:SERVER_HOST."




# name: CI/CD - Next.js Build & Windows Deploy (Multi-Server Stable)

# on:
#   push:
#     branches: ["main"]
#   workflow_dispatch:
#   schedule:
#     - cron: "31 18 * * *" # 12:01 AM IST (18:31 UTC)

# jobs:
#   build-and-deploy:
#     runs-on: windows-latest
#     strategy:
#       fail-fast: false  # ‚úÖ don‚Äôt cancel other servers if one fails
#       matrix:
#         include:
#           - name: server1
#             label: SERVER1
#           - name: server2
#             label: SERVER2

#     name: Deploy to ${{ matrix.name }}

#     steps:
#       # ------------------ CI: BUILD ------------------
#       - name: üõí Checkout repository
#         uses: actions/checkout@v4

#       - name: ‚öôÔ∏è Set up Node.js
#         uses: actions/setup-node@v4
#         with:
#           node-version: 20

#       - name: üì¶ Install dependencies
#         run: npm ci
#         shell: powershell

#       - name: üèóÔ∏è Build Next.js app
#         run: |
#           Write-Host "üèóÔ∏è Building Next.js app..."
#           npx next telemetry disable
#           npm run build
#         shell: powershell

#       - name: üóúÔ∏è Create build archive (safe include)
#         shell: pwsh
#         run: |
#           Write-Host "üóúÔ∏è Creating build archive safely..."
#           if (Test-Path "next-build.tar.gz") { Remove-Item next-build.tar.gz -Force }

#           # Check mandatory items
#           if (-not (Test-Path ".next")) { Write-Host "‚ùå .next folder missing!"; exit 1 }
#           if (-not (Test-Path "package.json")) { Write-Host "‚ùå package.json missing!"; exit 1 }

#           # Collect items
#           $tarItems = @(".next", "package.json")
#           if (Test-Path "public") { $tarItems += "public" }
#           if (Test-Path "next.config.js") { $tarItems += "next.config.js" }

#           Write-Host "üì¶ Archiving: $($tarItems -join ', ')"
#           cmd /c "tar -czf next-build.tar.gz $($tarItems -join ' ')"
#           if ($LASTEXITCODE -eq 0) {
#             Write-Host "‚úÖ Build archive created successfully."
#           } else {
#             Write-Host "‚ö†Ô∏è tar returned non-zero exit code ($LASTEXITCODE)."
#             exit 1
#           }

#       # ------------------ CD: DEPLOY ------------------
#       - name: üöÄ Deploy via WinRM HTTP (Port 5985)
#         continue-on-error: true  # ‚úÖ Don‚Äôt cancel workflow if one server fails
#         shell: pwsh
#         env:
#           SERVER1_HOST: ${{ secrets.SERVER1_HOST }}
#           SERVER1_USER: ${{ secrets.SERVER1_USER }}
#           SERVER1_PASS: ${{ secrets.SERVER1_PASS }}
#           SERVER2_HOST: ${{ secrets.SERVER2_HOST }}
#           SERVER2_USER: ${{ secrets.SERVER2_USER }}
#           SERVER2_PASS: ${{ secrets.SERVER2_PASS }}
#         run: |
#           # üß† Select correct server credentials dynamically
#           switch ("${{ matrix.label }}") {
#             "SERVER1" {
#               $env:SERVER_HOST = $env:SERVER1_HOST
#               $env:SERVER_USER = $env:SERVER1_USER
#               $env:SERVER_PASS = $env:SERVER1_PASS
#             }
#             "SERVER2" {
#               $env:SERVER_HOST = $env:SERVER2_HOST
#               $env:SERVER_USER = $env:SERVER2_USER
#               $env:SERVER_PASS = $env:SERVER2_PASS
#             }
#           }

#           Write-Host "üîß Configuring WinRM client..."
#           try {
#             winrm set winrm/config/client/auth '@{Basic="true"}'
#             winrm set winrm/config/client '@{TrustedHosts="*"}'
#             winrm set winrm/config/client '@{AllowUnencrypted="true"}'
#             Write-Host "‚úÖ WinRM client configured successfully."
#           } catch {
#             Write-Host "‚ùå WinRM configuration failed: $($_.Exception.Message)"
#             exit 1
#           }

#           Write-Host "üîó Connecting to $env:SERVER_HOST..."
#           $secpass = ConvertTo-SecureString $env:SERVER_PASS -AsPlainText -Force
#           $creds = New-Object System.Management.Automation.PSCredential ($env:SERVER_USER, $secpass)
#           $session = $null
#           for ($i = 1; $i -le 5; $i++) {
#             try {
#               Write-Host "üß† Attempt ${i}: Creating PSSession..."
#               $session = New-PSSession -ComputerName $env:SERVER_HOST -Port 5985 `
#                 -Credential $creds -Authentication Basic -UseSSL:$false -ErrorAction Stop
#               Write-Host "‚úÖ Connected successfully."
#               break
#             } catch {
#               Write-Host "‚ö†Ô∏è Connection failed (${i}): $($_.Exception.Message)"
#               Start-Sleep -Seconds 5
#               if ($i -eq 5) { throw "‚ùå Failed after 5 attempts." }
#             }
#           }

#           # Ensure target path exists
#           Invoke-Command -Session $session -ScriptBlock {
#             if (!(Test-Path "C:\inetpub\wwwroot\next-app")) {
#               New-Item -ItemType Directory -Path "C:\inetpub\wwwroot\next-app" | Out-Null
#               Write-Host "üìÅ Created deployment folder."
#             }
#           }

#           Write-Host "üì¶ Uploading build..."
#           Copy-Item -ToSession $session -Path "next-build.tar.gz" `
#             -Destination "C:\inetpub\wwwroot\next-app\next-build.tar.gz" -Force
#           Write-Host "‚úÖ Build uploaded successfully."

#           Write-Host "üß© Running remote deployment..."
#           Invoke-Command -Session $session -ScriptBlock {
#             $deployPath = "C:\inetpub\wwwroot\next-app"
#             Set-Location $deployPath

#             Write-Host "üìÇ Extracting new build..."
#             if (Test-Path ".next") { Remove-Item .next -Recurse -Force }
#             if (Test-Path "package.json") { Remove-Item package.json -Force }
#             if (Test-Path "public") { Remove-Item public -Recurse -Force }
#             tar -xzf next-build.tar.gz
#             Remove-Item next-build.tar.gz -Force

#             Write-Host "‚öôÔ∏è Installing dependencies (this may take a few minutes)..."
#             $keepAlive = Start-Job -ScriptBlock {
#               while ($true) {
#                 Write-Host "üí§ npm install still running... $(Get-Date -Format 'HH:mm:ss')"
#                 Start-Sleep -Seconds 60
#               }
#             }

#             try {
#               npm install --omit=dev --no-audit --no-fund --prefer-offline
#             }
#             finally {
#               try {
#                 Stop-Job $keepAlive -ErrorAction SilentlyContinue | Out-Null
#                 Remove-Job $keepAlive -ErrorAction SilentlyContinue | Out-Null
#               } catch {
#                 Write-Host "‚ö†Ô∏è Could not stop keep-alive job (safe to ignore)."
#               }
#             }

#             Write-Host "‚úÖ Dependencies installed successfully."

#             Write-Host "üõ†Ô∏è Ensuring PM2 is available..."
#             $pm2Path = 'C:\Users\Administrator\AppData\Roaming\npm'
#             if (!(Test-Path "$pm2Path\pm2.ps1")) {
#               npm install pm2 -g
#               Write-Host "‚úÖ PM2 installed globally."
#             }
#             [System.Environment]::SetEnvironmentVariable("Path", $env:Path + ";$pm2Path", [System.EnvironmentVariableTarget]::Process)
#             $env:Path += ";$pm2Path"

#             Write-Host "üîÑ Restarting or starting app with PM2..."
#             try {
#               pm2 delete next-app -s 2>$null | Out-Null
#               pm2 start npm --name "next-app" -- run start --no-warnings | Out-Null
#               pm2 save | Out-Null
#               Write-Host "‚úÖ PM2 restarted successfully."
#             } catch {
#               Write-Host "‚ö†Ô∏è PM2 error:"; Write-Host $_.Exception.Message
#             }

#             $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
#             Add-Content "$deployPath\deploy-log.txt" "Deployed successfully at $timestamp"
#             Write-Host "üöÄ Deployment completed successfully."
#           }

#           Remove-PSSession $session
#           Write-Host "‚úÖ Deployment finished for $env:SERVER_HOST."




name: CI/CD - Next.js Build & Windows Deploy (Multi-Server with Backup)

on:
  push:
    branches: ["main"]
  workflow_dispatch:
  schedule:
    - cron: "31 18 * * *" # 12:01 AM IST (18:31 UTC)

jobs:
  build-and-deploy:
    runs-on: windows-latest
    strategy:
      fail-fast: false # ‚úÖ Continue if one server fails
      matrix:
        include:
          - name: server1
            label: SERVER1
          - name: server2
            label: SERVER2

    name: Deploy to ${{ matrix.name }}

    steps:
      # ------------------ CI: BUILD ------------------
      - name: üõí Checkout repository
        uses: actions/checkout@v4

      - name: ‚öôÔ∏è Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: üì¶ Install dependencies
        run: npm ci
        shell: powershell

      - name: üèóÔ∏è Build Next.js app
        run: |
          Write-Host "üèóÔ∏è Building Next.js app..."
          npx next telemetry disable
          npm run build
        shell: powershell

      - name: üóúÔ∏è Create build archive (safe include)
        shell: pwsh
        run: |
          Write-Host "üóúÔ∏è Creating build archive safely..."
          if (Test-Path "next-build.tar.gz") { Remove-Item next-build.tar.gz -Force }

          # Validate mandatory build outputs
          if (-not (Test-Path ".next")) { Write-Host "‚ùå .next folder missing!"; exit 1 }
          if (-not (Test-Path "package.json")) { Write-Host "‚ùå package.json missing!"; exit 1 }

          $tarItems = @(".next", "package.json")
          if (Test-Path "public") { $tarItems += "public" }
          if (Test-Path "next.config.js") { $tarItems += "next.config.js" }

          Write-Host "üì¶ Archiving: $($tarItems -join ', ')"
          cmd /c "tar -czf next-build.tar.gz $($tarItems -join ' ')"
          if ($LASTEXITCODE -eq 0) {
            Write-Host "‚úÖ Build archive created successfully."
          } else {
            Write-Host "‚ö†Ô∏è tar returned non-zero exit code ($LASTEXITCODE)."
            exit 1
          }

      # ------------------ CD: DEPLOY ------------------
      - name: üöÄ Deploy via WinRM HTTP (Port 5985)
        continue-on-error: true
        shell: pwsh
        env:
          SERVER1_HOST: ${{ secrets.SERVER1_HOST }}
          SERVER1_USER: ${{ secrets.SERVER1_USER }}
          SERVER1_PASS: ${{ secrets.SERVER1_PASS }}
          SERVER2_HOST: ${{ secrets.SERVER2_HOST }}
          SERVER2_USER: ${{ secrets.SERVER2_USER }}
          SERVER2_PASS: ${{ secrets.SERVER2_PASS }}
        run: |
          # üß† Select correct server credentials dynamically
          switch ("${{ matrix.label }}") {
            "SERVER1" {
              $env:SERVER_HOST = $env:SERVER1_HOST
              $env:SERVER_USER = $env:SERVER1_USER
              $env:SERVER_PASS = $env:SERVER1_PASS
            }
            "SERVER2" {
              $env:SERVER_HOST = $env:SERVER2_HOST
              $env:SERVER_USER = $env:SERVER2_USER
              $env:SERVER_PASS = $env:SERVER2_PASS
            }
          }

          Write-Host "üîß Configuring WinRM client..."
          try {
            winrm set winrm/config/client/auth '@{Basic="true"}'
            winrm set winrm/config/client '@{TrustedHosts="*"}'
            winrm set winrm/config/client '@{AllowUnencrypted="true"}'
            Write-Host "‚úÖ WinRM client configured successfully."
          } catch {
            Write-Host "‚ùå WinRM configuration failed: $($_.Exception.Message)"
            exit 1
          }

          Write-Host "üîó Connecting to $env:SERVER_HOST..."
          $secpass = ConvertTo-SecureString $env:SERVER_PASS -AsPlainText -Force
          $creds = New-Object System.Management.Automation.PSCredential ($env:SERVER_USER, $secpass)

          $session = $null
          for ($i = 1; $i -le 5; $i++) {
            try {
              Write-Host "üß† Attempt ${i}: Creating PSSession..."
              $session = New-PSSession -ComputerName $env:SERVER_HOST -Port 5985 `
                -Credential $creds -Authentication Basic -UseSSL:$false -ErrorAction Stop
              Write-Host "‚úÖ Connected successfully."
              break
            } catch {
              Write-Host "‚ö†Ô∏è Connection failed (${i}): $($_.Exception.Message)"
              Start-Sleep -Seconds 5
              if ($i -eq 5) { throw "‚ùå Failed after 5 attempts." }
            }
          }

          # Ensure target path exists
          Invoke-Command -Session $session -ScriptBlock {
            $deployPath = "C:\inetpub\wwwroot\next-app"
            if (!(Test-Path $deployPath)) {
              Write-Host "üìÅ Creating deploy folder..."
              New-Item -ItemType Directory -Path $deployPath | Out-Null
            }
          }

          Write-Host "üì¶ Uploading build..."
          Copy-Item -ToSession $session -Path "next-build.tar.gz" `
            -Destination "C:\inetpub\wwwroot\next-app\next-build.tar.gz" -Force
          Write-Host "‚úÖ Build uploaded successfully."

          Write-Host "üß© Running remote deployment..."
          Invoke-Command -Session $session -ScriptBlock {
            $deployPath = "C:\inetpub\wwwroot\next-app"
            $backupPath = "$deployPath\backup_latest"
            Set-Location $deployPath

            # --- üóÇÔ∏è Backup Current Build ---
            Write-Host "üì¶ Creating backup of current build..."
            if (Test-Path $backupPath) {
              Write-Host "‚ôªÔ∏è Removing old backup..."
              Remove-Item $backupPath -Recurse -Force
            }
            New-Item -ItemType Directory -Path $backupPath | Out-Null

            if (Test-Path ".next") { Copy-Item ".next" -Destination "$backupPath\.next" -Recurse -Force }
            if (Test-Path "package.json") { Copy-Item "package.json" -Destination "$backupPath\" -Force }
            if (Test-Path "public") { Copy-Item "public" -Destination "$backupPath\public" -Recurse -Force }

            Write-Host "‚úÖ Backup completed successfully."

            # --- üß© Extract New Build ---
            Write-Host "üìÇ Extracting new build..."
            if (Test-Path ".next") { Remove-Item .next -Recurse -Force }
            if (Test-Path "package.json") { Remove-Item package.json -Force }
            if (Test-Path "public") { Remove-Item public -Recurse -Force }

            tar -xzf next-build.tar.gz
            Remove-Item next-build.tar.gz -Force
            Write-Host "‚úÖ Extraction complete."

            # --- ‚öôÔ∏è Install Dependencies ---
            Write-Host "‚öôÔ∏è Installing dependencies..."
            npm install --omit=dev --no-audit --no-fund --prefer-offline
            Write-Host "‚úÖ Dependencies installed successfully."

            $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
            Add-Content "$deployPath\deploy-log.txt" "Deployed successfully at $timestamp"
            Write-Host "üöÄ Deployment completed successfully."
          }

          Remove-PSSession $session
          Write-Host "‚úÖ Deployment finished for $env:SERVER_HOST."
